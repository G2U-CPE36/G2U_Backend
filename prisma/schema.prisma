datasource db {
  provider = "postgresql" 
  url      = env("DATABASE_URL") 
}

generator client {
  provider = "prisma-client-js"
}
// Define the UserLog model for logging user actions
model UserLog {
  logId     Int      @id @default(autoincrement()) // Primary key
  userId    Int
  action    String   // Action performed by the user (e.g., login, update profile)
  timestamp DateTime @default(now()) // Time of the log entry
  User      User     @relation(fields: [userId], references: [userId]) // Relation to User model
}

// Define the User model
model User {
  userId      Int       @id @default(autoincrement()) // Primary key
  username    String    @unique // Username must be unique
  email       String    @unique // Email must be unique
  password    String    // User's password
  createdOn   DateTime  @default(now()) // Date and time when the user was created
  firstName   String?   // Optional first name
  lastName    String?   // Optional last name
  phone       String?   // Optional phone number
  Products    Product[] // Relation to products created by the user
  Favorites   Favorite[] // Relation to user's favorite products
  UserLogs    UserLog[]  // Relation to logs of the user actions
  Auctions    Auction[] // Relation to auctions created by the user
  OpenOrders  OpenOrder[] // Relation to user's open orders
  UserAddresses UserAddress[] // Relation to user's addresses
  UserPayments UserPayment[] // Relation to user's payment methods
  UserWallets UserWallet[] // Relation to user's wallet
  Verifications Verification[] // Relation to user's verification status
  AuctionLogs AuctionLog[] // Relation to user's auction logs
  status       String?        // Optional status field (e.g., "active", "inactive")
 


}
model Favorite {
  favoriteId  Int      @id @default(autoincrement())
  userId      Int
  favoriteItem String   // TEXT type in SQL can be represented as String in Prisma
  User        User     @relation(fields: [userId], references: [userId])
}



model AuctionLog {
  auctionLogId   Int      @id @default(autoincrement())
  userId         Int
  auctionId      Int
  bidPrice       Int
  timestamp      DateTime // Use DateTime instead of TIMESTAMP
  User           User     @relation(fields: [userId], references: [userId])
  Auction        Auction  @relation(fields: [auctionId], references: [auctionId])
}


model Auction {
  auctionId   Int   @id @default(autoincrement())
  userId      Int
  productId   Int
  startPrice  Int
  minimumBid  Int
  start       Int   // Consider using DateTime for timestamps
  end         Int   // Consider using DateTime for timestamps
  User        User  @relation(fields: [userId], references: [userId])
  AuctionLogs AuctionLog[] // Add this line for the relation
}

model OpenOrder {
  openOrderId      Int      @id @default(autoincrement())
  userId           Int
  productName      String   // TEXT type in SQL can be represented as String in Prisma
  categoryId       Int
  productDescription String   // TEXT type in SQL can be represented as String in Prisma
  productImage     String   // TEXT type in SQL can be represented as String in Prisma
  User             User     @relation(fields: [userId], references: [userId])
}



model Product {
  productId       Int      @id @default(autoincrement())
  userId          Int
  productName     String   // TEXT type in SQL can be represented as String in Prisma
  categoryId      Int
  productDescription String   // TEXT type in SQL can be represented as String in Prisma
  productImage    String   // TEXT type in SQL can be represented as String in Prisma
  User            User     @relation(fields: [userId], references: [userId])
  Category        Category @relation(fields: [categoryId], references: [categoryId])
}

model UserAddress {
  addressId      Int      @id @default(autoincrement())
  userId         Int
  province       String
  district       String
  subDistrict    String?  // Optional
  postcode       Int
  address        String?  // Optional for TEXT
  note           String?  // Optional for TEXT
  receiverName   String
  phone          BigInt
  User           User     @relation(fields: [userId], references: [userId])
}

model Category {
  categoryId     Int      @id @default(autoincrement())
  categoryName   String
  detail         String?  // Optional for TEXT
  Products       Product[]
}

model WalletLog {
  walletLogId    Int   @id @default(autoincrement())
  walletId       Int
  transactionType Int
  value          Int
  UserWallet     UserWallet @relation(fields: [walletId], references: [walletId])
}

model UserPayment {
  paymentId      Int      @id @default(autoincrement())
  userId         Int
  paymentType    Int
  data1          String?  // Optional for TEXT
  data2          String?  // Optional for TEXT
  data3          String?  // Optional for TEXT
  User           User     @relation(fields: [userId], references: [userId])
}

model UserWallet {
  walletId       Int      @id @default(autoincrement())
  userId         Int
  currentValue    Int
  User           User     @relation(fields: [userId], references: [userId])
  WalletLogs     WalletLog[]
}


model Verification {
  verificationId  Int      @id @default(autoincrement())
  userId          Int
  citizenId       BigInt
  verificationStatus Int
  picture         String   // TEXT type in SQL can be represented as String in Prisma
  User            User     @relation(fields: [userId], references: [userId])
}